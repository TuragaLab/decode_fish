# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/09_output_trafo.ipynb (unless otherwise specified).

__all__ = ['sample_to_df', 'SIPostProcess', 'ISIPostProcess']

# Cell
from ..imports import *
import torch.nn.functional as F
from .plotting import *

# Cell
def sample_to_df(locs, x_os, y_os, z_os, ints, px_size=[100,100,100]):

    n_locs = len(ints)

    x = locs[-1] + x_os + 0.5
    y = locs[-2] + y_os + 0.5
    z = locs[-3] + z_os + 0.5

    frame_idx = locs[0]
    loc_idx = torch.arange(n_locs)

    df = DF({'loc_idx': loc_idx.cpu(),
                       'frame_idx': frame_idx.cpu(),
                       'x': x.cpu()*px_size[0],
                       'y': y.cpu()*px_size[1],
                       'z': z.cpu()*px_size[2],
                       'int': ints.cpu()})

    return df

# Cell
class SIPostProcess(torch.nn.Module):

    def __init__(self, m1_threshold:float = 0.03, m2_threshold:float = 0.3, samp_threshold=0.1, px_size=[100,100,100], diag=0):

        super().__init__()
        self.m1_threshold = m1_threshold
        self.m2_threshold = m2_threshold
        self.samp_threshold = samp_threshold
        self.diag = diag
        self.px_size = px_size

        if not diag:
            d1 = 0; d2 = 0
        else:
            d1 = 1/np.sqrt(2); d2 = 1/np.sqrt(3)
        self.filt = torch.FloatTensor([[[d2,d1,d2],[d1,1,d1],[d2,d1,d2]],
                                       [[d1, 1,d1],[1, 1, 1],[d1, 1,d1]],
                                       [[d2,d1,d2],[d1,1,d1],[d2,d1,d2]]])[None,None]

    def spatial_integration(self, p):

        device = p.device

        with torch.no_grad():

            p_copy = p + 0

            # probability values > threshold are regarded as possible locations
            p_clip = torch.where(p>self.m1_threshold,p,torch.zeros_like(p))

            # localize maximum values within a 3x3 patch
            pool = F.max_pool3d(p_clip,3,1,padding=1)
            max_mask1 = torch.eq(p, pool).float()

            # Add probability values from the 4 adjacent pixels
            conv = F.conv3d(p, self.filt.to(device) ,padding=1)
            p_ps1 = (max_mask1 * conv)

            # In order do be able to identify two fluorophores in adjacent pixels we look for probablity values > 0.5 that are not part of the first mask

            p_copy *= (1-max_mask1)
            p_clip = torch.where(p_copy>self.m2_threshold, p_copy,torch.zeros_like(p_copy))
            max_mask2 = torch.where(p_copy>self.m2_threshold, torch.ones_like(p_copy),torch.zeros_like(p_copy))
            p_ps2 = max_mask2*conv

            # This is our final clustered probablity which we then threshold (normally > 0.7) to get our final discrete locations
            p_ps = p_ps1 + p_ps2

            return p_ps

    def forward(self, res_dict, ret='df'):

        probs =  torch.sigmoid(res_dict['logits'])
        res_dict['Probs_si'] = self.spatial_integration(probs)
        res_dict['Samples_si'] = torch.where(res_dict['Probs_si'] > self.samp_threshold, torch.ones_like(res_dict['Probs_si']), torch.zeros_like(res_dict['Probs_si']))

        if ret == 'df':

            res_dict = {k:v.cpu() for (k,v) in res_dict.items()}
            samples = res_dict['Samples_si']
            nonz_idx = samples.nonzero(as_tuple=True)

            pos_x, pos_y, pos_z = nonz_idx[-1] ,nonz_idx[-2], nonz_idx[-3]
            x = pos_x + res_dict['xyzi_mu'][:,[0]][nonz_idx] + 0.5
            y = pos_y + res_dict['xyzi_mu'][:,[1]][nonz_idx] + 0.5
            z = pos_z + res_dict['xyzi_mu'][:,[2]][nonz_idx] + 0.5

            loc_idx = torch.arange(len(x))
            frame_idx = nonz_idx[0]

            df = DF({'loc_idx': loc_idx,
                               'frame_idx': frame_idx,
                               'x': x*self.px_size[0],
                               'y': y*self.px_size[1],
                               'z': z*self.px_size[2],
                               'prob': res_dict['Probs_si'][nonz_idx],
                               'int': res_dict['xyzi_mu'][:,[3]][nonz_idx],
                               'int_sig': res_dict['xyzi_sigma'][:,[3]][nonz_idx],
                               'x_sig': res_dict['xyzi_sigma'][:,[0]][nonz_idx]*self.px_size[0],
                               'y_sig': res_dict['xyzi_sigma'][:,[1]][nonz_idx]*self.px_size[1],
                               'z_sig': res_dict['xyzi_sigma'][:,[2]][nonz_idx]*self.px_size[2]})

            return df

        elif ret == 'micro':

            locations = res_dict['Samples_si'].nonzero(as_tuple=True)
            x_os_3d = res_dict['xyzi_mu'][:,[0]][locations]
            y_os_3d = res_dict['xyzi_mu'][:,[1]][locations]
            z_os_3d = res_dict['xyzi_mu'][:,[2]][locations]
            ints_3d = res_dict['xyzi_mu'][:,[3]][locations]
            output_shape  = res_dict['Samples_si'].shape

            return locations, x_os_3d, y_os_3d, z_os_3d, ints_3d, output_shape

        elif ret == 'dict':

            return res_dict

#export
class ISIPostProcess(SIPostProcess):

    def __init__(self, m1_threshold:float = 0.1, samp_threshold=0.1, px_size=[100,100,100], diag=False):

        super().__init__(m1_threshold = m1_threshold, samp_threshold=samp_threshold, px_size=px_size, diag=diag)
        self.m2_threshold = None

    def spatial_integration(self, p):

        device = p.device

        with torch.no_grad():

            p_ret = 0
            tot_mask = torch.ones_like(p)

            while True:

                p_copy = p + 0

                # probability values > threshold are regarded as possible locations
                p_clip = torch.where(p>self.m1_threshold,p,torch.zeros_like(p))*tot_mask

                # localize maximum values within a 3x3 patch
                pool = F.max_pool3d(p_clip,3,1,padding=1)
                max_mask1 = torch.eq(p, pool).float()
                max_mask1[p==0] = 0
                max_mask1 *= tot_mask

                tot_mask *= (torch.ones_like(max_mask1) - max_mask1)

                # Add probability values from the adjacent pixels
                conv = F.conv3d(p, self.filt.to(device) ,padding=1)
                p_ps = torch.clamp_max(max_mask1 * conv, 1)

                p_ret += p_ps

                p_proc = F.conv3d(max_mask1, self.filt.to(device),padding=1)*p
                p_proc = p_proc/p_proc.sum() * p_ps.sum()

                p = p - p_proc
                torch.clamp_min_(p, 0)

                if not max_mask1.sum():
                    break

            return p_ret