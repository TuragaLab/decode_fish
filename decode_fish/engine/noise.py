# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/03_noise.ipynb (unless otherwise specified).

__all__ = ['sCMOS', 'estimate_noise_scale']

# Cell
from ..imports import *
from torch import nn
from torch import distributions as D
from ..funcs.utils import *
from ..funcs.plotting import *
import scipy.stats as stats

# Cell
class sCMOS(nn.Module):
    """
    Generates sCMOS noise distribution.
    Generates sCMOS noise distribution which can be used for sampling and
    calculating log probabilites.

    Args:
        theta (float): Paramter for gamma distribution
        background (float): background value
        baseline (float): basline

    Shape:
        -Input: x_sim: (BS, C, H, W, D)

        -Output: Gamma(concentration: (BS, C, H, W, D), rate:
        (BS, C, H, W, D))
    """
    def __init__(self,
                 theta: float = 3.,
                 baseline: float = 0.01):
        super().__init__()
        self.theta = torch.nn.Parameter(torch.tensor(theta))
        self.register_buffer('baseline', torch.tensor(baseline))

    def forward(self, x_sim, background):

        x_sim_background = x_sim + background
#         x_sim_background.clamp_(1.0)

        conc = (x_sim_background - self.baseline) / self.theta
        xsim_dist = D.Gamma(concentration=conc, rate=1 / self.theta)

        loc_trafo = [D.AffineTransform(loc=self.baseline, scale=1)]
        xsim_dist = D.TransformedDistribution(xsim_dist, loc_trafo)
        return xsim_dist

# Cell
def estimate_noise_scale(img, bg_est, percentile=99, plot=True):

    img = cpu(img)
    bg_est = cpu(bg_est)
    residual = np.clip(img - bg_est + bg_est.mean(), img.min(), 1e10)
    fit_vals = residual[residual < np.percentile(residual, percentile)]
    fit_alpha, fit_loc, fit_beta=stats.gamma.fit(fit_vals, floc=0)

    if plot:
        _ = plt.hist(fit_vals,bins=np.linspace(fit_vals.min(),fit_vals.max(), 51),  histtype ='step',label='data', density=True)
        x = np.linspace(fit_vals.min(),fit_vals.max(),101)
        y = stats.gamma.pdf(x, fit_alpha, fit_loc, fit_beta)
        plt.plot(x, y, label='Fit')
        plt.legend()

    return fit_beta