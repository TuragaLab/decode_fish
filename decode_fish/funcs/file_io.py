# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/07_file_io.ipynb (unless otherwise specified).

__all__ = ['tiff_imread', 'load_model_state', 'simfish_to_df', 'load_sim_fish', 'big_fishq_to_df', 'rsfish_to_df',
           'load_tiff_image', 'swap_psf_vol', 'get_gaussian_psf', 'load_psf', 'load_psf_noise_micro', 'load_post_proc']

# Cell
from ..imports import *
from .utils import *
from tifffile import imread
from ..engine.microscope import Microscope
from ..engine.psf import crop_psf
from ..engine.psf import LinearInterpolatedPSF
from .emitter_io import *

# Cell
def tiff_imread(path):
    '''helper function to read tiff file with pathlib object or str'''
    if isinstance(path, str) : return imread(path)
    if isinstance(path, Path): return imread(str(path))

# Cell
def load_model_state(model, path, file_name ='model.pkl'):
    model_dict = torch.load(Path(path)/file_name)
    model.load_state_dict(model_dict['state_dict'])
    model.unet.inp_scale = model_dict['scaling'][0]
    model.unet.inp_offset = model_dict['scaling'][1]
    return model

# Cell
def simfish_to_df(sim_file, frame_idx=0):

    yxzi = []
    with open(sim_file) as f:
        read = False
        for line in f:
            if 'Pos_Y' in line:
                read = True
                continue
            if 'SPOTS_END' in line: break
            if read: yxzi.append([float(s) for s in line.split()])

    yxzi = np.array(yxzi)#/px_size
    loc_idx = np.arange(len(yxzi))
    # Number calculated by taking into account their (or my?) normalization (by max and not by sum)
    if yxzi.shape[1] == 4:
        # PSF.max() | PSF.sum() | 3**3 (superres)  | PSF.max() | microscope scale
        # ints = yxzi[:,3] * 65535.0 * 156772560.0 / 27 / 65535.0 / 10000.0
        ints = yxzi[:,3] * 65535.0 / 100.0
    else:
        ints = np.ones_like(loc_idx)

    df = pd.DataFrame({'loc_idx': loc_idx,
                       'frame_idx': frame_idx,
                       'x': yxzi[:,1],
                       'y': yxzi[:,0],
                       'z': yxzi[:,2],
                       'prob': np.ones_like(loc_idx),
                       'int': ints,
                       'int_sig': np.ones_like(loc_idx),
                       'x_sig': np.ones_like(loc_idx),
                       'y_sig': np.ones_like(loc_idx),
                       'z_sig': np.ones_like(loc_idx)})

    return df

#export
def load_sim_fish(basedir, mrna_lvl=200, shape='cell3D', exp_strength='strong', cell_nr=0, shift=[-38,-38,-110]):

    spec_dir = f'/mRNAlevel_{mrna_lvl}/{shape}/{exp_strength}/'
    img_path = sorted(glob.glob(basedir + spec_dir + 'w1*.tif'))[cell_nr]
    cellname = Path(img_path).name.split('.')[0]
#     print(name)
    img = load_tiff_image(img_path)
    gt_df = simfish_to_df(img_path.split('.')[0] + '.txt')
    fq_nog_df = fq_gmm_df = DF()
    if os.path.exists(basedir + '/_results_detection/'):
        nog_path = Path(basedir + '/_results_detection/' + spec_dir + '/results_noGMM/' + cellname + '_res_NO_GMM.txt')
        gmm_path = Path(basedir + '/_results_detection/' + spec_dir + '/results_GMM/' + cellname + '_res_GMM.txt')

        if nog_path.is_file():
            fq_nog_df = simfish_to_df(nog_path)
            fq_nog_df = shift_df(fq_nog_df, shift)
        if gmm_path.is_file():
            fq_gmm_df = simfish_to_df(gmm_path)
            fq_gmm_df = shift_df(fq_gmm_df, shift)

    return img, gt_df, fq_nog_df, fq_gmm_df

#export
def big_fishq_to_df(file_str):

    csv = pd.read_csv(file_str,sep=';',names=['z','y','x'], index_col=False)

    zyx = np.array(csv)
    loc_idx = np.arange(len(zyx))

    df = pd.DataFrame({'loc_idx': loc_idx,
                       'frame_idx': np.zeros_like(loc_idx),
                       'x': zyx[:,2],
                       'y': zyx[:,1],
                       'z': zyx[:,0],
                       'prob': np.ones_like(loc_idx),
                       'int': np.ones_like(loc_idx),
                       'int_sig': np.ones_like(loc_idx),
                       'x_sig': np.ones_like(loc_idx),
                       'y_sig': np.ones_like(loc_idx),
                       'z_sig': np.ones_like(loc_idx)})

    return df

def rsfish_to_df(file_str):

    csv = pd.read_csv(file_str,sep='  ',names=['x','y','z','?','??'], index_col=False)

    xyz = np.array(csv)
    loc_idx = np.arange(len(xyz))

    df = pd.DataFrame({'loc_idx': loc_idx,
                       'frame_idx': np.zeros_like(loc_idx),
                       'x': xyz[:,1],
                       'y': xyz[:,0],
                       'z': xyz[:,2],
                       'prob': np.ones_like(loc_idx),
                       'int': np.ones_like(loc_idx),
                       'int_sig': np.ones_like(loc_idx),
                       'x_sig': np.ones_like(loc_idx),
                       'y_sig': np.ones_like(loc_idx),
                       'z_sig': np.ones_like(loc_idx)})

    return df

# Cell
def load_tiff_image(image_path: str):
    "Given tiff stack path, loads the stack and converts it to a tensor. If necessary adds a dimension for the batch size"
    image_path = Path(image_path)
    image  = torch.tensor(tiff_imread(image_path).astype('float32'))
    if len(image.shape) == 3: image.unsqueeze_(0)
    assert len(image.shape) == 4, 'the shape of image must be 4, (1, Z, X, Y)'
    #removing minum values of the image
    return image

# Cell
def swap_psf_vol(psf, vol):
    state_dict = psf.state_dict()
    state_dict['psf_volume'][0] = torch.cuda.FloatTensor(torch.Tensor(vol).cuda())
    psf.load_state_dict(state_dict)
    return psf

def get_gaussian_psf(size_zyx, radii):
    psf = LinearInterpolatedPSF(size_zyx, device='cuda')
    gauss_vol = gaussian_sphere(size_zyx, radii, [size_zyx[0]//2,size_zyx[1]//2,size_zyx[2]//2])
    gauss_vol = gauss_vol/gauss_vol.max()
#     gauss_vol = np.log(gauss_vol+1e-6)
    psf = swap_psf_vol(psf, gauss_vol)
    return psf

def load_psf(cfg):

    if cfg.data_path.psf_path:
        if 'tif' in cfg.data_path.psf_path:
            psf_vol = load_tiff_image(cfg.data_path.psf_path)
#             psf_vol = torch.log(psf_vol)
            psf = LinearInterpolatedPSF(psf_vol.shape[-3:], cfg.PSF.device)
            psf = swap_psf_vol(psf, psf_vol)

        else:
            psf_state = torch.load(cfg.data_path.psf_path)
            psf = LinearInterpolatedPSF(psf_state['psf_volume'].shape[-3:], cfg.PSF.device)
            psf.load_state_dict(psf_state)

            if cfg.PSF.psf_extent_zyx:
                psf = crop_psf(psf,cfg.PSF.psf_extent_zyx)

    else:

        psf = get_gaussian_psf(cfg.PSF.psf_extent_zyx, cfg.PSF.gauss_radii)

    return psf

def load_psf_noise_micro(cfg):

    psf = load_psf(cfg)
    noise = hydra.utils.instantiate(cfg.noise)
    micro = hydra.utils.instantiate(cfg.microscope, parametric_psf=[psf], noise=noise).cuda()

    return psf, noise, micro

def load_post_proc(cfg):
    if cfg.other.pp == 'si':
        return hydra.utils.instantiate(cfg.post_proc_si)
    if cfg.other.pp == 'isi':
        return hydra.utils.instantiate(cfg.post_proc_isi)