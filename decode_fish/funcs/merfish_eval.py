# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/19_MERFISH_routines.ipynb (unless otherwise specified).

__all__ = ['get_benchmark_from_starfish', 'get_benchmark', 'get_istdeco', 'index', 'norm_features',
           'approximate_nearest_code', 'vcorrcoef', 'bce_code', 'get_code_from_ints', 'match_bench',
           'plot_gene_numbers', 'plot_gene_panels', 'make_roc']

# Cell
from ..imports import *
from .file_io import *
from .emitter_io import *
from .utils import *
from .dataset import *
from .plotting import *
from ..engine.noise import estimate_noise_scale
import shutil
from .visualization import *
from .predict import predict

from numba import njit
from scipy.spatial import cKDTree
from .evaluation import matching

import io, requests
from sklearn.neighbors import NearestNeighbors
from starfish import data
import torch.tensor as T
import pprint

# Cell
def get_benchmark_from_starfish(magnitude_threshold=10**0.75*4):

    bench = pd.read_csv(
        io.BytesIO(requests.get('https://d2nhj9g34unfro.cloudfront.net/MERFISH/benchmark_results.csv').content),
        dtype={'barcode': object})

    #See Fig. S4 https://www.pnas.org/content/113/39/11046

    bench_df = bench.copy()
    bench_df = bench_df[bench_df['total_magnitude']>magnitude_threshold]
    bench_df = bench_df[bench_df['area']>3]

    print(len(bench_df))

    experiment = data.MERFISH(use_test_data=True)
    code_ref = experiment.codebook.data.reshape([140,-1], order='F')
    targets = experiment.codebook.indexes['target']

    bench_df.loc[:,'frame_idx'] = 0
    bench_df.loc[:,'loc_idx'] = np.arange(len(bench_df))
    bench_df.loc[:,'int'] = bench_df['total_magnitude']
    bench_df.loc[:,'z'] = 50/100
    bench_df = px_to_nm(bench_df)

    return bench_df, code_ref, targets

def get_benchmark(magnitude_threshold=10**0.75*4):

    bench = pd.read_csv(base_path + '/decode_fish/data/merfish_bench_df.csv')

    #See Fig. S4 https://www.pnas.org/content/113/39/11046

    bench_df = bench.copy()
    bench_df = bench_df[bench_df['total_magnitude']>magnitude_threshold]
    bench_df = bench_df[bench_df['area']>3]

    print(len(bench_df))

    code_ref = np.load(base_path + '/decode_fish/data/merfish_code_ref.npz')['arr_0']
    targets = np.load(base_path + '/decode_fish/data/merfish_targets.npz', allow_pickle=True)['arr_0']

    bench_df.loc[:,'frame_idx'] = 0
    bench_df.loc[:,'code_inds'] = bench_df['barcode_id'].values - 1
    bench_df.loc[:,'loc_idx'] = np.arange(len(bench_df))
    bench_df.loc[:,'int'] = bench_df['total_magnitude']
    bench_df.loc[:,'z'] = 50/100
    bench_df = px_to_nm(bench_df)
    bench_df = bench_df.drop('barcode_id', axis=1)
    return bench_df, code_ref, targets

def get_istdeco():
    istdeco_df = pd.read_csv('../../decode_fish/data/results/ISTDECO.csv')
    istdeco_df = istdeco_df.rename(columns={'target_name':'gene'})
    fov = [40,40,2008,2008]
    istdeco_df = istdeco_df[ (istdeco_df['x'] >= fov[0]) & (istdeco_df['x'] <= fov[2])  & (istdeco_df['y'] >= fov[1]) & (istdeco_df['y'] <= fov[3])]

    istdeco_df.loc[:,'frame_idx'] = 0
    istdeco_df.loc[:,'code_inds'] = istdeco_df['target_id'].values - 1
    istdeco_df.loc[:,'loc_idx'] = np.arange(len(istdeco_df))
    istdeco_df.loc[:,'int'] = istdeco_df['intensity']
    istdeco_df.loc[:,'z'] = 50/100
    istdeco_df = px_to_nm(istdeco_df)
    istdeco_df = istdeco_df.drop('target_id', axis=1)

    print(len(istdeco_df))
    return istdeco_df

# Cell
@njit
def index(array, item):
    for idx, val in np.ndenumerate(array):
        if val == item:
            return idx[0]
    return None

def norm_features(code, norm_order = 2):

    norm = np.linalg.norm(code, ord=norm_order, axis=1)
    code = code / norm[:, None]

    return code

def approximate_nearest_code(ref_code, pred_code, targets):

    nn = NearestNeighbors(n_neighbors=1, algorithm='ball_tree', metric='euclidean').fit(ref_code)
    metric_output, indices = nn.kneighbors(pred_code)
    gene_ids = np.ravel(targets.values[indices])

    return np.ravel(metric_output), gene_ids, indices

def vcorrcoef(X,y):
    Xm = np.reshape(np.mean(X,axis=1),(X.shape[0],1))
    ym = np.mean(y)
    r_num = np.sum((X-Xm)*(y-ym),axis=1)
    r_den = np.sqrt(np.sum((X-Xm)**2,axis=1)*np.sum((y-ym)**2))
    r = r_num/r_den
    return 1-r

def bce_code(ref_code, pred_code):

    bce = torch.nn.BCELoss(reduction='none')
    return np.array(bce(T(ref_code, dtype=torch.float32), T(pred_code[None].repeat(len(ref_code),0), dtype=torch.float32)).mean(-1))

# export
def get_code_from_ints(pred_df, code_ref, targets, func=vcorrcoef, int_str='', p_str=''):

    int_keys = [f'int_{p_str}{i}{int_str}' for i in range(16)]
    int_pred = pred_df[int_keys].values

    res_df = pred_df.copy()

    code_err = []
    code_ind = []

    for i in range(len(int_pred)):

        code_errors = func(code_ref, int_pred[i])
        min_ind = np.argmin(code_errors)
        code_err.append(code_errors[min_ind])
        code_ind.append(min_ind)

    res_df['code_err'] = code_err
    res_df['code_inds'] = code_ind
    res_df['gene'] = targets[code_ind]

    return res_df

# Cell
def match_bench(pred_df, bench_df):

    bench_match = bench_df.copy()
    pred_df.loc[:,'frame_idx'] = 0

    _,_,shift = matching(bench_match, pred_df, tolerance=250, print_res=False)
    print(shift)
    bench_match = shift_df(bench_match, shift=-np.array(shift))

    _,_,shift = matching(bench_match, pred_df, tolerance=250, print_res=False)

    bench_match = shift_df(bench_match, shift=-np.array(shift))
    _,matches,shift = matching(bench_match, pred_df, tolerance=250, print_res=True)

    return matches, bench_match

# Cell
def plot_gene_numbers(bench_counts, res_counts, title='', log=True, corr=True):

    if corr:
        r = np.corrcoef(bench_counts, res_counts)[0, 1]
        r = np.round(r, decimals=3)
    else:
        r = [int(np.sum(bench_counts)), int(np.sum(res_counts))]
    x_lim = np.max([bench_counts.max(), res_counts.max()])
    x = np.linspace(0, x_lim)

    plt.scatter(bench_counts, res_counts, 50, zorder=2)
    plt.plot(x, x, '-k', zorder=1)

    plt.xlabel('Gene copy number Benchmark')
    plt.ylabel('Gene copy number DECODE')
    if log:
        plt.xscale('log')
        plt.yscale('log')
    plt.title(f'{title} r = {r}');

# Cell
def plot_gene_panels(res_df, bench_df, targets, matches=None):

    bench_counts = DF(data=None, index=targets)
    bench_counts['Res_all'] = res_df.groupby('gene')['gene'].count()
    bench_counts['Bench_all'] = bench_df.groupby('gene')['gene'].count()
    bench_counts = bench_counts.fillna(0)

    if matches is not None:
        fps = res_df.loc[~res_df['loc_idx'].isin(matches['loc_idx_pred'])]
        fns = bench_df.loc[~bench_df['loc_idx'].isin(matches['loc_idx_tar'])]

        bench_counts['Res_fp'] = fps.groupby('gene')['gene'].count()
        bench_counts['Res_fns'] = fns.groupby('gene')['gene'].count()

    bench_counts=bench_counts.fillna(0)

    print(len(bench_df), len(res_df))

    plt.figure(figsize=(15,5))
    plt.subplot(131)
    plot_gene_numbers(bench_counts['Bench_all'].values, bench_counts['Res_all'].values, 'All', log=False)

    binds = []
    for i,g in enumerate(targets):
        if 'Blank' in g:
            binds.append(g)

    plt.subplot(132)
    plot_gene_numbers(bench_counts.loc[binds, 'Bench_all'].values, bench_counts.loc[binds,'Res_all'].values, 'Blanks', log=False, corr=False)

    if 'Res_fp' in bench_counts:
        plt.subplot(133)
        plot_gene_numbers(bench_counts['Bench_all'].values, bench_counts['Res_fp'].values, 'False Pos.', log=False)

# Cell
def make_roc(df, var='code_err', ascending=True, n_max=30000):

    if n_max is None:
        n_max = len(df)
    x = np.arange(1000,n_max,100)
    df = df.sort_values(var, ascending=ascending)
    n_blanks = []
    for i in x:
        n_blanks.append((df[:int(i)]['gene'].str.contains('Blank')).sum())

    return x, n_blanks