# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/16_visualization.ipynb (unless otherwise specified).

__all__ = ['base_path', 'get_simulation_statistics', 'get_prediction', 'eval_random_crop', 'eval_random_sim']

# Cell
from ..imports import *
from .file_io import *
from .emitter_io import *
from .utils import *
from .dataset import *
from .output_trafo import *
from .evaluation import *
from .plotting import *
from torch.utils.data import DataLoader
from ..engine.microscope import Microscope
from ..engine.point_process import PointProcessUniform

import ipyvolume as ipv

base_path =  '/groups/turaga/home/speisera/Mackebox/Artur/WorkDB/deepstorm/'

# Cell
def get_simulation_statistics(decode_dl, micro, int_threshold=1, samples = 1):

    """
    Draws a sample from the dataloader, and plots a slice of the real volume, the extracted background and
    a slice from a simulated volume.


    """
    z_ind = 24
    with torch.no_grad():

        for _ in range(samples):

            xmax = 0
            while xmax < int_threshold:
                x, local_rate, background = next(iter(decode_dl))
                xmax = x[0,0,z_ind].max()

            x = x[0,0,z_ind].cpu().numpy()

            xsim = micro(*PointProcessUniform(local_rate, min_int=decode_dl.min_int).sample())
            xsim_noise = micro.noise(xsim, background).sample()

            xsim_noise = xsim_noise.cpu().numpy()[0,0,z_ind]
            background = background[0,0].cpu().numpy()

            fig = plt.figure(figsize=(18,6))
            plt.subplot(131)
            im = plt.imshow(x)
            add_colorbar(im)
            plt.title('Real Image ')

            plt.subplot(132)
            im = plt.imshow(background.mean(0))
            add_colorbar(im)
            plt.title('Background')

            plt.subplot(133)
            im = plt.imshow(xsim_noise)
            add_colorbar(im)
            plt.title('Sim. Image ')

            plt.show()

# Cell
def get_prediction(model, img, micro=None, cuda=True, px_size=np.array([100.,100.,100.]), return_rec=False, threshold=0.1):

    with torch.no_grad():

        img = img[(None,)*(5-img.ndim)]
        model.eval().cuda() if cuda else model.eval().cpu()
        res_dict = model(img.cuda()) if cuda else model(img)
        pred_df = model_output_to_df(res_dict, threshold, px_size=px_size)

        if return_rec:
            ae_img_3d = micro(*model_output_to_micro_input(res_dict, threshold=threshold))
            return pred_df, ae_img_3d + res_dict['background']

        return pred_df

def eval_random_crop(decode_dl, model, micro, projection='mean', px_size=np.array([100.,100.,100.]), cuda=False, threshold=0.1, samples=1):

    with torch.no_grad():

        for _ in range(samples):

            x, local_rate, background = next(iter(decode_dl))
            pred_df, rec = get_prediction(model, x[:1], micro=micro, cuda=True, return_rec=True, threshold=threshold)
            pred_df = nm_to_px(pred_df, px_size)

            x = x[0,0].cpu().numpy()
            rec = rec[0,0].cpu().numpy()

            axes = plot_3d_projections(x, projection=projection)
            axes[0].scatter(pred_df['x'],pred_df['y'], color='red', s=5.)
            axes[1].scatter(pred_df['x'],pred_df['z'], color='red', s=5.)
            axes[2].scatter(pred_df['y'],pred_df['z'], color='red', s=5.)

            axes[1].set_title('Predictions', size=16)

            axes = plot_3d_projections(rec, projection=projection)

            axes[1].set_title('Reconstruction', size=16)

def eval_random_sim(decode_dl, model, micro, projection='mean', px_size=np.array([100.,100.,100.]), cuda=False, threshold=0.1, samples=1):

    with torch.no_grad():

        for _ in range(samples):

            x, local_rate, background = next(iter(decode_dl))

            sim_vars = PointProcessUniform(local_rate, min_int=decode_dl.min_int).sample()
            xsim = micro(*sim_vars)
            x = micro.noise(xsim, background).sample()

            pred_df, rec = get_prediction(model, x[:1], micro=micro, cuda=True, return_rec=True, threshold=threshold)
            pred_df = nm_to_px(pred_df, px_size)

            x = x[0,0].cpu().numpy()
            rec = rec[0,0].cpu().numpy()

            axes = plot_3d_projections(x, projection=projection)
            axes[0].scatter(pred_df['x'],pred_df['y'], color='red', s=5.)
            axes[1].scatter(pred_df['x'],pred_df['z'], color='red', s=5.)
            axes[2].scatter(pred_df['y'],pred_df['z'], color='red', s=5.)

            axes[1].set_title('Predictions', size=16)

            axes = plot_3d_projections(rec, projection=projection)

            axes[1].set_title('Reconstruction', size=16)