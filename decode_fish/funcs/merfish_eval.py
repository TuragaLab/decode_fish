# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/19_MERFISH_routines.ipynb (unless otherwise specified).

__all__ = ['index', 'norm_features', 'approximate_nearest_code', 'vcorrcoef', 'bce_code', 'get_code_from_ints',
           'match_bench', 'plot_gene_numbers', 'plot_gene_panels', 'make_roc']

# Cell
from ..imports import *
from .file_io import *
from .emitter_io import *
from .utils import *
from .dataset import *
from .plotting import *
from ..engine.noise import estimate_noise_scale
import shutil
from .visualization import *
from .predict import predict

from numba import njit
from scipy.spatial import cKDTree
from .evaluation import matching

import io, requests
from sklearn.neighbors import NearestNeighbors
from starfish import data
import torch.tensor as T
import pprint

# Cell
@njit
def index(array, item):
    for idx, val in np.ndenumerate(array):
        if val == item:
            return idx[0]
    return None

def norm_features(code, norm_order = 2):

    norm = np.linalg.norm(code, ord=norm_order, axis=1)
    code = code / norm[:, None]

    return code

def approximate_nearest_code(ref_code, pred_code, targets):

    nn = NearestNeighbors(n_neighbors=1, algorithm='ball_tree', metric='euclidean').fit(ref_code)
    metric_output, indices = nn.kneighbors(pred_code)
    gene_ids = np.ravel(targets.values[indices])

    return np.ravel(metric_output), gene_ids, indices

def vcorrcoef(X,y):
    Xm = np.reshape(np.mean(X,axis=1),(X.shape[0],1))
    ym = np.mean(y)
    r_num = np.sum((X-Xm)*(y-ym),axis=1)
    r_den = np.sqrt(np.sum((X-Xm)**2,axis=1)*np.sum((y-ym)**2))
    r = r_num/r_den
    return 1-r

def bce_code(ref_code, pred_code):

    bce = torch.nn.BCELoss(reduction='none')
    return np.array(bce(T(ref_code, dtype=torch.float32), T(pred_code[None].repeat(len(ref_code),0), dtype=torch.float32)).mean(-1))

# export
def get_code_from_ints(pred_df, code_ref, targets, func=vcorrcoef, int_str='', p_str=''):

    int_keys = [f'int_{p_str}{i}{int_str}' for i in range(16)]
    int_pred = pred_df[int_keys].values

    res_df = pred_df.copy()

    code_err = []
    code_ind = []

    for i in range(len(int_pred)):

        code_errors = func(code_ref, int_pred[i])
        min_ind = np.argmin(code_errors)
        code_err.append(code_errors[min_ind])
        code_ind.append(min_ind)

    res_df['code_err'] = code_err
    res_df['code_inds'] = code_ind
    res_df['gene'] = targets[code_ind]

    return res_df

# Cell
def match_bench(pred_df, bench_df):

    bench_match = bench_df.copy()
    pred_df.loc[:,'frame_idx'] = 0

    _,_,shift = matching(bench_match, pred_df, tolerance=250, print_res=False)
    print(shift)
    bench_match = shift_df(bench_match, shift=-np.array(shift))

    _,_,shift = matching(bench_match, pred_df, tolerance=250, print_res=False)

    bench_match = shift_df(bench_match, shift=-np.array(shift))
    _,matches,shift = matching(bench_match, pred_df, tolerance=250, print_res=True)

    return matches, bench_match

# Cell
def plot_gene_numbers(bench_counts, res_counts, title='', log=True, corr=True):

    if corr:
        r = np.corrcoef(bench_counts, res_counts)[0, 1]
        r = np.round(r, decimals=3)
    else:
        r = [int(np.sum(bench_counts)), int(np.sum(res_counts))]
    x_lim = np.max([bench_counts.max(), res_counts.max()])
    x = np.linspace(0, x_lim)

    plt.scatter(bench_counts, res_counts, 50, zorder=2)
    plt.plot(x, x, '-k', zorder=1)

    plt.xlabel('Gene copy number Benchmark')
    plt.ylabel('Gene copy number DECODE')
    if log:
        plt.xscale('log')
        plt.yscale('log')
    plt.title(f'{title} r = {r}');

# Cell
def plot_gene_panels(res_df, bench_df, targets, matches=None):

    bench_counts = DF(data=None, index=targets)
    bench_counts['Res_all'] = res_df.groupby('gene')['gene'].count()
    bench_counts['Bench_all'] = bench_df.groupby('gene')['gene'].count()
    bench_counts = bench_counts.fillna(0)

    if matches is not None:
        fps = res_df.loc[~res_df['loc_idx'].isin(matches['loc_idx_pred'])]
        fns = bench_df.loc[~bench_df['loc_idx'].isin(matches['loc_idx_tar'])]

        bench_counts['Res_fp'] = fps.groupby('gene')['gene'].count()
        bench_counts['Res_fns'] = fns.groupby('gene')['gene'].count()

    bench_counts=bench_counts.fillna(0)

    print(len(bench_df), len(res_df))

    plt.figure(figsize=(15,5))
    plt.subplot(131)
    plot_gene_numbers(bench_counts['Bench_all'].values, bench_counts['Res_all'].values, 'All', log=False)

    binds = []
    for i,g in enumerate(targets):
        if 'Blank' in g:
            binds.append(g)

    plt.subplot(132)
    plot_gene_numbers(bench_counts.loc[binds, 'Bench_all'].values, bench_counts.loc[binds,'Res_all'].values, 'Blanks', log=False, corr=False)

    if 'Res_fp' in bench_counts:
        plt.subplot(133)
        plot_gene_numbers(bench_counts['Bench_all'].values, bench_counts['Res_fp'].values, 'False Pos.', log=False)

# Cell
def make_roc(df, var='code_err', ascending=True, n_max=30000):

    if n_max is None:
        n_max = len(df)
    x = np.arange(1000,n_max,100)
    df = df.sort_values(var, ascending=ascending)
    n_blanks = []
    for i in x:
        n_blanks.append((df[:int(i)]['gene'].str.contains('Blank')).sum())

    return x, n_blanks