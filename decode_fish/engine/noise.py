# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/03_noise.ipynb (unless otherwise specified).

__all__ = ['sCMOS', 'estimate_noise_scale']

# Cell
from ..imports import *
from torch import nn
from torch import distributions as D
from ..funcs.utils import *
from ..funcs.plotting import *
import scipy.stats as stats

# Cell
class sCMOS(nn.Module):
    """
    Generates sCMOS noise distribution which can be used for sampling and
    calculating log probabilites.

    Theta can be learned (but no the baseline)

    Args:
        theta (float): 1/theta gives the rate for torch.distributions.gamma
        baseline (float): baseline

    """
    def __init__(self,
                 theta: float = 3.,
                 baseline: float = 0.,
                 channels: int = 0):
        super().__init__()

        if channels:
            self.theta_scale = theta * channels
            self.theta_par = torch.nn.Parameter(torch.ones(channels)/channels)
            self.channel_shifts = torch.nn.Parameter(torch.zeros([channels, 3]))
        else:
            self.theta_scale = theta
            self.theta_par = torch.nn.Parameter(torch.tensor(1.))

        self.theta_const = (self.theta_scale * self.theta_par).detach().cuda()

        self.register_buffer('baseline', torch.tensor(baseline))
        self.channels = channels

    def forward(self, x_sim, background, rec_ch=None, const_theta_sim=False):
        """ Calculates the concentration (mean / theta) of a Gamma distribution given
        the signal x_sim and background tensors.
        Also applies a shift and returns resulting the Gamma distribution
        """

        theta = (self.theta_scale * self.theta_par)
        if const_theta_sim:
            theta = self.theta_const
        if rec_ch:
            theta = theta[rec_ch].reshape([1,1,1,1,1])
            background = background[:,rec_ch:rec_ch+1]
        else:
            theta = theta[None,:,None,None,None]

        x_sim_background = x_sim + background
        x_sim_background.clamp_(1.0 + self.baseline)

        conc = (x_sim_background - self.baseline) / theta
        xsim_dist = D.Gamma(concentration=conc, rate=1 / theta)

        loc_trafo = [D.AffineTransform(loc=self.baseline, scale=1)]
        xsim_dist = D.TransformedDistribution(xsim_dist, loc_trafo)
        return xsim_dist

# Cell
def estimate_noise_scale(img, bg_est, percentile=99, plot=True):
    """ Returns an estimate of theta given a volume and a background estimate

    Args:
        img: recorded volume for which we want to estimate the noise
        bg_est: estimated background for img
        percentile: we wan't to exclude the signal for our fit. therefore we only use the lower percentile of all voxels
        plot: whether to plot the data and the final fit

    Returns:
        fit_theta: theta estimate
    """

    img = cpu(img)
    bg_est = cpu(bg_est)
    residual = np.clip(img - bg_est + bg_est.mean(), img.min(), 1e10)
    fit_vals = residual[residual < np.percentile(residual, percentile)]
    fit_alpha, fit_loc, fit_theta=stats.gamma.fit(fit_vals, floc=0)

    if plot:
        _ = plt.hist(fit_vals,bins=np.linspace(fit_vals.min(),fit_vals.max(), 51),  histtype ='step',label='data', density=True)
        x = np.linspace(fit_vals.min(),fit_vals.max(),101)
        y = stats.gamma.pdf(x, fit_alpha, fit_loc, fit_theta)
        plt.plot(x, y, label='Fit')
        plt.legend()

    return fit_theta