# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/16_visualization.ipynb (unless otherwise specified).

__all__ = ['base_path', 'get_simulation_statistics', 'get_prediction', 'eval_random_crop', 'eval_random_sim']

# Cell
from ..imports import *
from .file_io import *
from .emitter_io import *
from .utils import *
from .dataset import *
from .output_trafo import *
from .evaluation import *
from .plotting import *
from torch.utils.data import DataLoader
from ..engine.microscope import Microscope
from ..engine.point_process import PointProcessUniform

import ipyvolume as ipv

base_path =  '/groups/turaga/home/speisera/Mackebox/Artur/WorkDB/deepstorm/'

# Cell
def get_simulation_statistics(decode_dl, micro, int_threshold=1, samples = 1):

    """
    Draws a sample from the dataloader, and plots a slice of the real volume, the extracted background and
    a slice from a simulated volume.


    """
    z_ind = 24
    with torch.no_grad():

        for _ in range(samples):

            xmax = 0
            while xmax < int_threshold:
                x, local_rate, background = next(iter(decode_dl))
                xmax = x[0,0,z_ind].max()

            x = x[0,0,z_ind].cpu().numpy()

            sim_vars = PointProcessUniform(local_rate, min_int=decode_dl.min_int).sample()
            xsim = micro(*sim_vars)
            xsim_noise = micro.noise(xsim, background).sample()
            sim_df = sample_to_df(*sim_vars[:-1])
            sim_df = sim_df[sim_df['frame_idx'] == 0]

            xsim_noise = xsim_noise.cpu().numpy()[0,0,z_ind]
            background = background[0,0].cpu().numpy()

            fig = plt.figure(figsize=(18,6))
            plt.subplot(131)
            im = plt.imshow(x)
            add_colorbar(im)
            plt.title('Real Image ')

            plt.subplot(132)
            im = plt.imshow(background.mean(0))
            add_colorbar(im)
            plt.title('Background')

            plt.subplot(133)
            im = plt.imshow(xsim_noise)
            add_colorbar(im)
            plt.title('Sim. Image ')
            plt.scatter(sim_df['x']/100,sim_df['y']/100, color='red', s=5.)

            plt.show()

# Cell
def get_prediction(model, post_proc, img, micro=None, cuda=True, return_rec=False):

    with torch.no_grad():

        img = img[(None,)*(5-img.ndim)]
        model.eval().cuda() if cuda else model.eval().cpu()
        res_dict = model(img.cuda()) if cuda else model(img)
        pred_df = post_proc(res_dict)

        if return_rec:
            ae_img_3d = micro(*post_proc(res_dict, ret='micro'))
            return pred_df, ae_img_3d + res_dict['background'], res_dict

        return pred_df

def eval_random_crop(decode_dl, model, post_proc, micro, projection='mean', cuda=False, samples=1):

    with torch.no_grad():

        for _ in range(samples):

            x, local_rate, background = next(iter(decode_dl))
            pred_df, rec, res_dict = get_prediction(model, post_proc, x[:1], micro=micro, cuda=True, return_rec=True)
            pred_df = nm_to_px(pred_df, post_proc.px_size)

            x = x[0,0].cpu().numpy()
            rec = rec[0,0].cpu().numpy()

            axes = plot_3d_projections(x, projection=projection)
            axes[0].scatter(pred_df['x'],pred_df['y'], color='red', s=5.)
            axes[1].scatter(pred_df['x'],pred_df['z'], color='red', s=5.)
            axes[2].scatter(pred_df['y'],pred_df['z'], color='red', s=5.)

            axes[1].set_title('Predictions', size=16)

            axes = plot_3d_projections(rec, projection=projection)

            axes[1].set_title('Reconstruction', size=16)

            pred_df, rec,res_dict

def eval_random_sim(decode_dl, model, post_proc, micro, projection='mean', plot_gt=True, cuda=True, samples=1):

    with torch.no_grad():

        for _ in range(samples):

            x, local_rate, background = next(iter(decode_dl))

            sim_vars = PointProcessUniform(local_rate, min_int=decode_dl.min_int).sample()
            xsim = micro(*sim_vars)
            x = micro.noise(xsim, background).sample()
            pred_df, rec, res_dict = get_prediction(model, post_proc, x[:1], micro=micro, cuda=True, return_rec=True)
            pred_df = nm_to_px(pred_df, post_proc.px_size)
            sim_df = nm_to_px(sample_to_df(*sim_vars[:-1]))
            sim_df = sim_df[sim_df['frame_idx']==0]

            x = x[0,0].cpu().numpy()
            rec = rec[0,0].cpu().numpy()

            axes = plot_3d_projections(x, projection=projection)

            if plot_gt:
                axes[0].scatter(sim_df['x'],sim_df['y'], color='black', marker='x', s=25.)
                axes[1].scatter(sim_df['x'],sim_df['z'], color='black', marker='x', s=25.)
                axes[2].scatter(sim_df['y'],sim_df['z'], color='black', marker='x', s=25.)

            axes[0].scatter(pred_df['x'],pred_df['y'], color='red', s=5.)
            axes[1].scatter(pred_df['x'],pred_df['z'], color='red', s=5.)
            axes[2].scatter(pred_df['y'],pred_df['z'], color='red', s=5.)

            axes[1].set_title('Predictions', size=16)

            axes = plot_3d_projections(rec, projection=projection)

            axes[1].set_title('Reconstruction', size=16)