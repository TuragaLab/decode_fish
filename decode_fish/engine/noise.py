# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/03_noise.ipynb (unless otherwise specified).

__all__ = ['GammaNoise']

# Cell
from ..imports import *
from torch import nn
from torch import distributions as D
from ..funcs.utils import *
import scipy.stats as stats

# Cell
class GammaNoise(nn.Module):
    """
    Generates GammaNoise noise distribution which can be used for sampling and
    calculating log probabilites.

    Theta can be learned (but not the baseline)

    Args:
        theta (float): 1/theta gives the rate for torch.distributions.gamma
        baseline (float): baseline (currently not used)

    """
    def __init__(self, theta = 3., baseline = 0., n_channels = 0):

        super().__init__()

        if n_channels > 1:
            self.theta_scale = torch.tensor(theta)
            self.theta_par = torch.nn.Parameter(torch.ones(n_channels))
        else:
            self.theta_scale = theta
            self.theta_par = torch.nn.Parameter(torch.tensor(1.))

        self.baseline = baseline
        self.n_channels = n_channels

    def forward(self, x_sim, background, ch_inds=None, randomize_range=None):
        """ Calculates the concentration (mean / theta) of a Gamma distribution given
        the signal x_sim and background tensors.
        Also applies a shift and returns resulting the Gamma distribution
        """

        theta = (self.theta_scale.to(self.theta_par.device) * self.theta_par)

        if randomize_range is not None:
            theta = theta * torch.zeros_like(theta).uniform_(*randomize_range)

        if ch_inds is None:
            theta = theta[None,:,None,None,None]
        else:
            theta = theta[ch_inds]
            theta = theta[:,None,None,None,None]

        x_sim_background = x_sim + background
        x_sim_background.clamp_(1.0 + self.baseline)

        conc = (x_sim_background - self.baseline) / theta
        xsim_dist = D.Gamma(concentration=conc, rate=1 / theta)

        loc_trafo = [D.AffineTransform(loc=self.baseline, scale=1)]
        xsim_dist = D.TransformedDistribution(xsim_dist, loc_trafo)

        return xsim_dist
