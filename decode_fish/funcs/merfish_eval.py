# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/19_MERFISH_routines.ipynb (unless otherwise specified).

__all__ = ['get_benchmark', 'get_istdeco', 'index', 'norm_features', 'approximate_nearest_code', 'vcorrcoef',
           'bce_code', 'match_bench', 'get_code_from_ints', 'plot_gene_numbers', 'make_roc']

# Cell
from ..imports import *
from .file_io import *
from .emitter_io import *
from .utils import *
from .dataset import *
from .plotting import *
from ..engine.noise import estimate_noise_scale
import shutil
from .visualization import *
from .predict import predict

from numba import njit
from scipy.spatial import cKDTree
from .evaluation import matching

import io, requests
from sklearn.neighbors import NearestNeighbors
from starfish import data
import torch.tensor as T
import pprint

# Cell
def get_benchmark(magnitude_threshold=10**0.75*4):

    bench = pd.read_csv(
        io.BytesIO(requests.get('https://d2nhj9g34unfro.cloudfront.net/MERFISH/benchmark_results.csv').content),
        dtype={'barcode': object})

    #See Fig. S4 https://www.pnas.org/content/113/39/11046

    bench_df = bench.copy()
    bench_df = bench_df[bench_df['total_magnitude']>magnitude_threshold]
    bench_df = bench_df[bench_df['area']>3]

    print(len(bench_df))

    experiment = data.MERFISH(use_test_data=True)
    code_ref = experiment.codebook.data.reshape([140,-1], order='F')
    targets = experiment.codebook.indexes['target']

    bench_df.loc[:,'frame_idx'] = 0
    bench_df.loc[:,'loc_idx'] = np.arange(len(bench_df))
    bench_df.loc[:,'int'] = bench_df['total_magnitude']
    bench_df.loc[:,'z'] = 50/100
    bench_df = px_to_nm(bench_df)

    return bench_df, code_ref, targets

def get_istdeco():
    istdeco_df = pd.read_csv('../../decode_fish/data/results/ISTDECO.csv')
    istdeco_df = istdeco_df.rename(columns={'target_name':'gene'})
    fov = [40,40,2008,2008]
    istdeco_df = istdeco_df[ (istdeco_df['x'] >= fov[0]) & (istdeco_df['x'] <= fov[2])  & (istdeco_df['y'] >= fov[1]) & (istdeco_df['y'] <= fov[3])]

    istdeco_df.loc[:,'frame_idx'] = 0
    istdeco_df.loc[:,'loc_idx'] = np.arange(len(istdeco_df))
    istdeco_df.loc[:,'int'] = istdeco_df['intensity']
    istdeco_df.loc[:,'z'] = 50/100
    istdeco_df = px_to_nm(istdeco_df)

    print(len(istdeco_df))
    return istdeco_df

# Cell
@njit
def index(array, item):
    for idx, val in np.ndenumerate(array):
        if val == item:
            return idx[0]
    return None

def norm_features(code, norm_order = 2):

    norm = np.linalg.norm(code, ord=norm_order, axis=1)
    code = code / norm[:, None]

    return code

def approximate_nearest_code(ref_code, pred_code, targets):

    nn = NearestNeighbors(n_neighbors=1, algorithm='ball_tree', metric='euclidean').fit(ref_code)
    metric_output, indices = nn.kneighbors(pred_code)
    gene_ids = np.ravel(targets.values[indices])

    return np.ravel(metric_output), gene_ids, indices

def vcorrcoef(X,y):
    Xm = np.reshape(np.mean(X,axis=1),(X.shape[0],1))
    ym = np.mean(y)
    r_num = np.sum((X-Xm)*(y-ym),axis=1)
    r_den = np.sqrt(np.sum((X-Xm)**2,axis=1)*np.sum((y-ym)**2))
    r = r_num/r_den
    return 1-r

def bce_code(ref_code, pred_code):

    bce = torch.nn.BCELoss(reduction='none')
    return bce(T(ref_code, dtype=torch.float32), T(pred_code[None].repeat(len(ref_code),0), dtype=torch.float32)).mean(-1)

# Cell
def match_bench(pred_df, bench_df):

    bench_match = bench_df.copy()
    pred_df.loc[:,'frame_idx'] = 0

    _,_,shift = matching(bench_match, pred_df, tolerance=250, print_res=False)
    print(shift)
    bench_match = shift_df(bench_match, shift=-np.array(shift))

    _,_,shift = matching(bench_match, pred_df, tolerance=250, print_res=False)

    bench_match = shift_df(bench_match, shift=-np.array(shift))
    _,matches,shift = matching(bench_match, pred_df, tolerance=250, print_res=True)

    return matches, bench_match

# Cell
def get_code_from_ints(pred_df, code_ref, targets, func=vcorrcoef, int_str=''):

    int_keys = [f'int_{i}{int_str}' for i in range(16)]
    int_pred = pred_df[int_keys].values

    res_df = pred_df.copy()

    code_err = []
    code_ind = []

    for i in range(len(int_pred)):

        code_errors = func(code_ref, int_pred[i])
        min_ind = np.argmin(code_errors)
        code_err.append(code_errors[min_ind])
        code_ind.append(min_ind)

    res_df['code_err'] = code_err
    res_df['code_inds'] = code_ind
    res_df['gene'] = targets[code_ind]

    return res_df

# Cell
def plot_gene_numbers(bench_counts, res_counts, title='', log=True, corr=True):

    if corr:
        r = np.corrcoef(bench_counts, res_counts)[0, 1]
        r = np.round(r, decimals=3)
    else:
        r = np.sum(res_counts)
    x_lim = np.max([bench_counts.max(), res_counts.max()])
    x = np.linspace(0, x_lim)

    plt.scatter(bench_counts, res_counts, 50, zorder=2)
    plt.plot(x, x, '-k', zorder=1)

    plt.xlabel('Gene copy number Benchmark')
    plt.ylabel('Gene copy number DECODE')
    if log:
        plt.xscale('log')
        plt.yscale('log')
    plt.title(f'{title} r = {r}');

# Cell
def make_roc(df, var='code_err', ascending=True):

    x = np.arange(1000,len(df),100)
    df = df.sort_values(var, ascending=ascending)
    n_blanks = []
    for i in x:
        n_blanks.append((df[:int(i)]['gene'].str.contains('Blank')).sum())

    return x, n_blanks