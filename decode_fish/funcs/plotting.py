# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/06_plotting.ipynb (unless otherwise specified).

__all__ = ['add_colorbar', 'sl_plot', 'gt_plot', 'plot_3d_projections', 'scat_3d_projections', 'plot_prob_hist',
           'extract_roi', 'plot_channels', 'combine_figures']

# Cell
from ..imports import *
from mpl_toolkits import axes_grid1
from matplotlib import pyplot as plt
from matplotlib import gridspec
import seaborn as sns
from .utils import *
from .emitter_io import nm_to_px
from matplotlib.backends.backend_agg import FigureCanvas

# Cell
def add_colorbar(im, aspect=20, pad_fraction=0.5, **kwargs):
    """ Add a vertical color bar to an image plot """

    divider = axes_grid1.make_axes_locatable(im.axes)
    width = axes_grid1.axes_size.AxesY(im.axes, aspect=1./aspect)
    pad = axes_grid1.axes_size.Fraction(pad_fraction, width)
    current_ax = plt.gca()
    cax = divider.append_axes("right", size=width, pad=pad)
    plt.sca(current_ax)
    return im.axes.figure.colorbar(im, cax=cax, **kwargs)

# Cell
def sl_plot(x, xsim, pred_df, target_df, background, res):

    pred_df = pred_df[pred_df['frame_idx']==0]
    target_df = target_df[target_df['frame_idx']==0]
    with torch.no_grad():
        fig = plt.figure(figsize=(20,4))
        plt.subplot(151)
        im = plt.imshow(x[0][0].cpu().numpy().max(0))
        add_colorbar(im)
        plt.axis('off')
        plt.title('Real image')

        plt.subplot(152)
        im = plt.imshow(xsim[0][0].cpu().numpy().max(0))
        plt.scatter(target_df['x'], target_df['y'],facecolors='black', marker='x', s=25.)
        plt.scatter(pred_df['x'], pred_df['y'],facecolors='red', marker='o', s=5.)
        add_colorbar(im)
        plt.axis('off')
        plt.title('Sim. image')

        plt.subplot(153)
        im = plt.imshow(torch.sigmoid(res['logits'][0][0]).cpu().numpy().max(0))
        add_colorbar(im)
        plt.axis('off')
        plt.title('Predicted locations')

        plt.subplot(154)
        im = plt.imshow(background[0][0].cpu().numpy().max(0))
        add_colorbar(im)
        plt.axis('off')
        plt.title('Background')

        plt.subplot(155)
        im = plt.imshow(res['background'][0][0].cpu().numpy().max(0))
        add_colorbar(im)
        plt.axis('off')
        plt.title('Predicted background')

    return fig

def gt_plot(x, pred_df, gt_df, px_size, gt_rec=None, psf=None, fig_size=(24,6)):

    with torch.no_grad():
        fig = plt.figure(figsize=fig_size)
        plt.subplot(141)

        x = x[0].cpu().numpy()

        max_proj = x.max(0)
        vmax = max_proj.max()
        im = plt.imshow(max_proj, vmax=vmax)
        add_colorbar(im)
        plt.scatter(pred_df['x'], pred_df['y'],facecolors='red', marker='+', s=20)
#         plt.scatter(gt_df['x'], gt_df['y'],facecolors='none', marker='o', s=20)
        plt.axis('off')
        plt.title('Real image')

        if gt_rec is not None:

            gt_rec = gt_rec[0].cpu().numpy()

            plt.subplot(142)
            im = plt.imshow(gt_rec.max(0), vmax=vmax)
            add_colorbar(im)
            plt.axis('off')
            plt.title('RMSE ' + str(np.round(np.sqrt(((x-gt_rec)**2).mean()),2)))

            plt.subplot(143)
            im = plt.imshow(abs(x - gt_rec).max(0))
            add_colorbar(im)
            plt.axis('off')

            if psf is not None:
                plt.subplot(144)
                psf_vol = psf.psf_volume[0].detach().cpu().numpy()
                if psf_vol.shape[0] == 1:
                    im = plt.imshow(psf.psf_volume[0].detach().cpu().numpy().mean(0))
                else:
                    im = plt.imshow(psf.psf_volume[0].detach().cpu().numpy().mean(1))
                plt.axis('off')

    return fig

def plot_3d_projections(volume, proj_func=np.max, size=6, vmax=None, display=True):

    if torch.is_tensor(volume):
        plot_vol = volume.detach().cpu().numpy()
    else:
        plot_vol = volume

    for _ in range(plot_vol.ndim - 3):
        plot_vol = plot_vol.squeeze(0)

    z,y,x = plot_vol.shape

    size_y = size * ((y+z)/y)
    size_x = size * ((1.1*x+z)/x)

    fig, ((ax_yx, ax_yz, ax_c), (ax_zx, ax_t1, ax_t2)) = plt.subplots(2, 3, figsize=(size_x,size_y), sharex='col', sharey=False,
                                                 gridspec_kw={'height_ratios': [y, z], 'width_ratios':[x, z, x/20]})
    plt.subplots_adjust(hspace=0.0,wspace=0.05)

    # usually imshow starts at -0.5 so we have to manually change that
    im = ax_yx.imshow(proj_func(plot_vol, 0),vmax=vmax, extent=(0,x,y,0))
    ax_yz.imshow(proj_func(plot_vol, 2).T,vmax=vmax, extent=(0,z,y,0))
    ax_zx.imshow(proj_func(plot_vol, 1),vmax=vmax, extent=(0,x,z,0))

    ax_t1.axis('off')
    ax_t2.axis('off')
#     ax_yz.axis('off')

    fig.colorbar(im, cax=ax_c)

    ax_yx.set_ylabel('y')
    ax_zx.set_xlabel('x')
    ax_zx.set_ylabel('z')

    ax_yz.set_xlabel('z')
    ax_yz.set_yticklabels([])

    plt.tight_layout()

    if not display: plt.close(fig)

    return fig, [ax_yx,ax_zx,ax_yz]

def scat_3d_projections(axes, dfs, px_size_zyx=[1.,1.,1], s_fac=1., labels=None):
    colors = ['red','black','orange']
    markers = ['o','+','x']
    if labels is None:
        labels=[f'DF {i}' for i in range(3)]

    if not isinstance(dfs, list):
        dfs = [dfs]
    for i,df in enumerate(dfs):
        df = nm_to_px(df, px_size_zyx)
        axes[0].scatter(df['x'],df['y'], color=colors[i], marker=markers[i], s=10*s_fac, label=labels[i])
        axes[1].scatter(df['x'],df['z'], color=colors[i], marker=markers[i], s=10*s_fac)
        axes[2].scatter(df['z'],df['y'], color=colors[i], marker=markers[i], s=10*s_fac)
    axes[0].legend()


def plot_prob_hist(res_dict):
    fig = plt.figure()
    plt.hist(cpu(torch.sigmoid(res_dict['logits'])).reshape(-1), bins=np.linspace(0.01,1,100))
    return fig

def extract_roi(vol_5d: torch.Tensor, coordinates: torch.Tensor, size_xy: int=10, size_z: int=10):
    res = []

    x, y, z = coordinates
    crop = np.s_[:,:, int(y-size_xy): int(y+size_xy+1), int(x-size_xy): int(x+size_xy+1)]
    single_bead = vol_5d[crop]

    return single_bead, crop

def plot_channels(volume, n_rows=1, dfs=None, codebook=None, proj_func=np.max, size=6, vmax=None, center=None, crop_sz=10, display=True):

    if torch.is_tensor(volume):
        plot_vol = volume.detach().cpu().numpy()
    else:
        plot_vol = volume

    for _ in range(plot_vol.ndim - 4):
        plot_vol = plot_vol.squeeze(0)

    ch = plot_vol.shape[0]
    n_cols = int(np.ceil(ch/n_rows))

    if center is not None:
        plot_vol, crop = extract_roi(plot_vol, center, crop_sz, 10000)
        if dfs is not None:
            dfs = [crop_df(df, crop) for df in dfs]

    size_y = size * n_rows
    size_x = size * n_cols

    fig, axes = plt.subplots(n_rows, n_cols, figsize=(size_x,size_y))
    plt.subplots_adjust(hspace=0.0,wspace=0.05)
    print(axes.shape)
#     if vmax is None:
#         vmax = plot_vol.max()

    colors = ['red', 'orange', 'white']

    for i in range(n_rows):
        for j in range(n_cols):

            curr_ind = i*n_cols + j
            if curr_ind >= len(plot_vol):
                continue

            im = axes[i, j].imshow(proj_func(plot_vol[curr_ind], 0),vmax=vmax)
            axes[i, j].axis('off')

            if dfs is not None:
                for k, df in enumerate(dfs):
                    sub_df = df[codebook[df['code_inds']][:,curr_ind] > 0]
                    axes[i, j].scatter(sub_df['x'],sub_df['y'], color=colors[k], s=10)

            if center is not None:
                axes[i, j].scatter(crop_sz,crop_sz, color='purple', s=125, marker='+')

#     fig.colorbar(im)

    plt.tight_layout()

    if not display: plt.close(fig)

    return fig, plot_vol, dfs

# Cell
def combine_figures(figures, titles, nrows=1, ncols=2, figsize=(10,5)):

    imgs = []
    for f in figures:
        canvas = FigureCanvas(f)
        canvas.draw()
        imgs.append(np.array(canvas.renderer.buffer_rgba()))

    figure = plt.figure(figsize=figsize)
    axes = figure.subplots(nrows, ncols)
    plt.subplots_adjust(hspace=0.,wspace=0.)

    axes = axes.reshape(-1)

    for i in range(len(imgs)):
        axes[i].imshow(imgs[i])
        axes[i].axis('off')
        if len(titles) >= len(imgs)-1:
            axes[i].set_title(titles[i])

    return figure