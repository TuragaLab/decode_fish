# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/09_output_trafo.ipynb (unless otherwise specified).

__all__ = ['sample_to_df', 'spatial_integration', 'model_output_to_df', 'model_output_to_micro_input']

# Cell
from ..imports import *
import torch.nn.functional as F
from .plotting import *

# Cell
def sample_to_df(locs, x_os, y_os, z_os, ints, px_size=[100,100,100]):

    n_locs = len(ints)

    x = locs[-1] + x_os + 0.5
    y = locs[-2] + y_os + 0.5
    z = locs[-3] + z_os + 0.5

    frame_idx = locs[0]
    loc_idx = torch.arange(n_locs)

    df = DF({'loc_idx': loc_idx.cpu(),
                       'frame_idx': frame_idx.cpu(),
                       'x': x.cpu()*px_size[0],
                       'y': y.cpu()*px_size[1],
                       'z': z.cpu()*px_size[2],
                       'int': ints.cpu()})

    return df

# Cell
def spatial_integration(p, threshold=0.03):

    diag=0
    device = p.device
    filt = torch.FloatTensor([[[diag,diag,diag],[diag,1,diag],[diag,diag,diag]],
                             [[diag,1,diag],[1,1,1],[diag,1,diag]],
                             [[diag,diag,diag],[diag,1,diag],[diag,diag,diag]]])[None,None].to(device)

    with torch.no_grad():

        p_copy = p + 0

        # probability values > threshold are regarded as possible locations
        p_clip = torch.where(p>threshold,p,torch.zeros_like(p))[:,None]

        # localize maximum values within a 3x3 patch
        pool = F.max_pool3d(p_clip,3,1,padding=1)
        max_mask1 = torch.eq(p[:,None], pool).float()

        # Add probability values from the 4 adjacent pixels
        conv = F.conv3d(p[:,None], filt ,padding=1)
        p_ps1 = (max_mask1 * conv)

        # In order do be able to identify two fluorophores in adjacent pixels we look for probablity values > 0.5 that are not part of the first mask

        p_copy *= (1-max_mask1[:,0])
        p_clip = torch.where(p_copy>0.5,p_copy,torch.zeros_like(p_copy))[:,None]
        max_mask2 = torch.where(p_copy>0.5,torch.ones_like(p_copy),torch.zeros_like(p_copy))[:,None]
        p_ps2 = max_mask2*conv

        # This is our final clustered probablity which we then threshold (normally > 0.7) to get our final discrete locations
        p_ps = p_ps1 + p_ps2

    return p_ps[:,0].cpu()

# Cell
def model_output_to_df(res_dict, threshold=0.1, px_size=[100,100,100]):

    probs =  torch.sigmoid(res_dict['logits'])
    res_dict['Probs_si'] = spatial_integration(probs[:,0])[:, None]
    res_dict['Samples_si'] = torch.where(res_dict['Probs_si'] > threshold, torch.ones_like(res_dict['Probs_si']), torch.zeros_like(res_dict['Probs_si']))

    res_dict = {k:v.cpu() for (k,v) in res_dict.items()}
    samples = res_dict['Samples_si']
    nonz_idx = samples.nonzero(as_tuple=True)

    pos_x, pos_y, pos_z = nonz_idx[-1] ,nonz_idx[-2], nonz_idx[-3]
    x = pos_x + res_dict['xyzi_mu'][:,[0]][nonz_idx] + 0.5
    y = pos_y + res_dict['xyzi_mu'][:,[1]][nonz_idx] + 0.5
    z = pos_z + res_dict['xyzi_mu'][:,[2]][nonz_idx] + 0.5

    loc_idx = torch.arange(len(x))
    frame_idx = nonz_idx[0]

    df = DF({'loc_idx': loc_idx,
                       'frame_idx': frame_idx,
                       'x': x*px_size[0],
                       'y': y*px_size[1],
                       'z': z*px_size[2],
                       'prob': res_dict['Probs_si'][nonz_idx],
                       'int': res_dict['xyzi_mu'][:,[3]][nonz_idx],
                       'int_sig': res_dict['xyzi_sigma'][:,[3]][nonz_idx],
                       'x_sig': res_dict['xyzi_sigma'][:,[0]][nonz_idx]*px_size[0],
                       'y_sig': res_dict['xyzi_sigma'][:,[1]][nonz_idx]*px_size[1],
                       'z_sig': res_dict['xyzi_sigma'][:,[2]][nonz_idx]*px_size[2]})

    return df

# Cell
def model_output_to_micro_input(res_dict, device='cuda', threshold = 0.6):

    probs =  torch.sigmoid(res_dict['logits'])
    res_dict['Probs_si'] = spatial_integration(probs[:,0])[:, None]
    res_dict['Samples_si'] = torch.where(res_dict['Probs_si'] > threshold, torch.ones_like(res_dict['Probs_si']), torch.zeros_like(res_dict['Probs_si']))

    for k in res_dict:
        res_dict[k] = res_dict[k].to(device)

    locations = res_dict['Samples_si'].nonzero(as_tuple=True)
    x_os_3d = res_dict['xyzi_mu'][:,[0]][locations]
    y_os_3d = res_dict['xyzi_mu'][:,[1]][locations]
    z_os_3d = res_dict['xyzi_mu'][:,[2]][locations]
    ints_3d = res_dict['xyzi_mu'][:,[3]][locations]
    output_shape  = res_dict['Samples_si'].shape

    return locations, x_os_3d, y_os_3d, z_os_3d, ints_3d, output_shape